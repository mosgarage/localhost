exports.id=928,exports.ids=[928],exports.modules={7114:(e,t,i)=>{i.d(t,{HomeWebviewProvider:()=>HomeWebviewProvider});var r=i(1398),s=i(8577),o=i(3037),n=i(1182),a=i(1849),h=i(3583),l=i(4123),u=i(5567),c=i(3782),p=i(5853),d=i(8219),g=i(6770),m=i(875),v=i(4154),w=i(4119),b=i(7865),f=i(9271),y=i(3631),C=i(7125),R=i(5962),P=i(1902),S=i(9975),_=i(4269),k=i(4898),D=i(2870),O=i(6162);async function I(e){let t=await e.launchpad.getCategorizedItems();if(null!=t.error)return{error:t.error};let i=D.H.get("launchpad.indicator.groups")??[];return(0,O.a)(t.items,i)}var B=i(8397),W=i(2141),$=i(9615),F=i(4152),q=i(3677),L=i(2966),H=i(5539),T=i(9091),M=i(7864);let SubscriptionManager=class SubscriptionManager{constructor(e,t){this.source=e,this.subscribe=t}_status="stopped";get status(){return this._status}_subscription;dispose(){this.stop()}start(){(null==this._subscription||"started"!==this._status)&&(this._subscription=this.subscribe(this.source),this._status="started")}pause(){this.stop("paused")}resume(){this.start()}stop(e){this._subscription?.dispose(),this._subscription=void 0,this._status=e??"stopped"}};var E=i(1017),U=i(486);let A="home",z=new U.Oz(A,"launchpad/summary"),x=new U.Oz(A,"overview/active"),N=new U.Oz(A,"overview/inactive"),G=new U.Oz(A,"overviewFilter"),Z=new U.Q2(A,"overview/repository/change"),Q=new U.C1(A,"overview/repository/didChange"),j=new U.Q2(A,"previewEnabled/toggle"),V=new U.Q2(A,"section/collapse"),Y=new U.Q2(A,"walkthrough/dismiss"),J=new U.Q2(A,"overview/filter/set"),K=new U.Q2(A,"openInGraph"),X=new U.C1(A,"repositories/didCompleteDiscovering"),ee=new U.C1(A,"previewEnabled/didChange"),et=new U.C1(A,"repository/wip/didChange"),ei=new U.C1(A,"repositories/didChange"),er=new U.C1(A,"walkthroughProgress/didChange"),es=new U.C1(A,"integrations/didChange"),eo=new U.C1(A,"launchpad/didChange"),en=new U.C1(A,"subscription/didChange"),ea=new U.C1(A,"org/settings/didChange"),eh=new U.C1(A,"home/ownerFilter/didChange"),el=new U.C1(A,"account/didFocus");var eu=Object.defineProperty,ec=Object.getOwnPropertyDescriptor,ep=(e,t,i,r)=>{for(var s,o=r>1?void 0:r?ec(t,i):t,n=e.length-1;n>=0;n--)(s=e[n])&&(o=(r?s(t,i,o):s(o))||o);return r&&o&&eu(t,i,o),o};let ed=Object.freeze({dispose:()=>{}}),eg={OneDay:864e5,OneWeek:6048e5,OneMonth:2592e6,OneYear:31536e6};let HomeWebviewProvider=class HomeWebviewProvider{constructor(e,t){this.container=e,this.host=t,this._disposable=r.Disposable.from(this.container.git.onDidChangeRepositories(this.onRepositoriesChanged,this),r.workspace.isTrusted?ed:r.workspace.onDidGrantWorkspaceTrust(()=>this.notifyDidChangeRepositories(),this),this.container.subscription.onDidChange(this.onSubscriptionChanged,this),(0,$.wt)(this.onContextChanged,this),this.container.integrations.onDidChangeConfiguredIntegrations(this.onIntegrationsChanged,this),this.container.walkthrough.onProgressChanged(this.onWalkthroughChanged,this),D.H.onDidChange(this.onDidChangeConfig,this),this.container.launchpad.onDidChange(this.onDidLaunchpadChange,this),this.container.ai.onDidChangeModel(this.onAIModelChanged,this))}_disposable;_discovering;_etag;_etagFileSystem;_etagRepository;_etagSubscription;_pendingFocusAccount=!1;dispose(){this._disposable.dispose()}getTelemetryContext(){return{...this.host.getTelemetryContext(),"context.preview":this.getPreviewEnabled()?"v16":void 0}}_overviewBranchFilter={recent:{threshold:"OneWeek"},stale:{threshold:"OneYear",show:!1,limit:9}};onShowing(e,t,...i){this._etag=this.container.git.etag,this.ensureRepoDiscovery();let[r]=i;if(r?.focusAccount===!0){if(!e&&this.host.ready&&this.host.visible)return queueMicrotask(()=>void this.host.notify(el,void 0)),[!0,void 0];this._pendingFocusAccount=!0}return[!0,void 0]}async ensureRepoDiscovery(){this.container.git.isDiscoveringRepositories&&(this._discovering=this.container.git.isDiscoveringRepositories,this._discovering.finally(()=>this._discovering=void 0),this._etag=await this._discovering,this.notifyDidCompleteDiscoveringRepositories())}onAIModelChanged(e){this.notifyDidChangeIntegrations()}onIntegrationsChanged(e){this.notifyDidChangeIntegrations()}async onChooseRepository(){let e=this.getSelectedRepository(),t=this.container.git.openRepositories.sort((t,i)=>(t===e?1:-1)-(i===e?1:-1)||(t.starred?-1:1)-(i.starred?-1:1)||t.index-i.index),i=await (0,B.oe)(`Switch Repository ${n.EO.Dot} ${e?.name}`,"Choose a repository to switch to",t);if(null!=i&&i!==e)return this.selectRepository(i.path)}onRepositoriesChanged(){null==this._discovering&&this._etag!==this.container.git.etag&&this.notifyDidChangeRepositories()}onWalkthroughChanged(){this.notifyDidChangeProgress()}onDidChangeConfig(e){D.H.changed(e,"home.preview.enabled")&&this.notifyDidChangeConfig()}onDidLaunchpadChange(){this.notifyDidChangeLaunchpad()}async push(e=!1){let t=this.getSelectedRepository();return t?(0,h.b)({command:"push",state:{repos:[t],flags:e?["--force"]:void 0}}):Promise.resolve()}async publishBranch(e){let{repo:t,branch:i}=await this.getRepoInfoFromRef(e);if(null!=i)return c.VC(t,void 0,(0,w.iw)(i))}async pull(){let e=this.getSelectedRepository();return e?(0,h.b)({command:"pull",state:{repos:[e]}}):Promise.resolve()}registerCommands(){return[(0,W.Lb)(`${this.host.id}.pull`,this.pull,this),(0,W.Lb)(`${this.host.id}.push`,e=>{this.push(e.force)},this),(0,W.Lb)(`${this.host.id}.publishBranch`,this.publishBranch,this),(0,W.Lb)(`${this.host.id}.refresh`,()=>this.host.refresh(!0),this),(0,W.Lb)(`${this.host.id}.disablePreview`,()=>this.onTogglePreviewEnabled(!1),this),(0,W.Lb)(`${this.host.id}.enablePreview`,()=>this.onTogglePreviewEnabled(!0),this),(0,W.Lb)(`${this.host.id}.previewFeedback`,()=>(0,F.CZ)("https://github.com/gitkraken/vscode-gitlens/discussions/3721"),this),(0,W.Lb)(`${this.host.id}.whatsNew`,()=>(0,F.CZ)(n.DS.releaseNotes),this),(0,W.Lb)(`${this.host.id}.help`,()=>(0,F.CZ)(n.DS.helpCenter),this),(0,W.Lb)(`${this.host.id}.issues`,()=>(0,F.CZ)(n.DS.githubIssues),this),(0,W.Lb)(`${this.host.id}.info`,()=>(0,F.CZ)(n.DS.helpCenterHome),this),(0,W.Lb)(`${this.host.id}.discussions`,()=>(0,F.CZ)(n.DS.githubDiscussions),this),(0,W.Lb)(`${this.host.id}.account.resync`,e=>this.container.subscription.validate({force:!0},e),this),(0,W.Lb)("gitlens.home.deleteBranchOrWorktree",this.deleteBranchOrWorktree,this),(0,W.Lb)("gitlens.home.pushBranch",this.pushBranch,this),(0,W.Lb)("gitlens.home.openMergeTargetComparison",this.mergeTargetCompare,this),(0,W.Lb)("gitlens.home.openPullRequestChanges",this.pullRequestChanges,this),(0,W.Lb)("gitlens.home.openPullRequestComparison",this.pullRequestCompare,this),(0,W.Lb)("gitlens.home.openPullRequestOnRemote",this.pullRequestViewOnRemote,this),(0,W.Lb)("gitlens.home.openPullRequestDetails",this.pullRequestDetails,this),(0,W.Lb)("gitlens.home.createPullRequest",this.pullRequestCreate,this),(0,W.Lb)("gitlens.home.openWorktree",this.worktreeOpen,this),(0,W.Lb)("gitlens.home.switchToBranch",this.switchToBranch,this),(0,W.Lb)("gitlens.home.fetch",this.fetch,this),(0,W.Lb)("gitlens.home.openInGraph",this.openInGraph,this),(0,W.Lb)("gitlens.home.createBranch",this.createBranch,this),(0,W.Lb)("gitlens.home.mergeIntoCurrent",this.mergeIntoCurrent,this),(0,W.Lb)("gitlens.home.rebaseCurrentOnto",this.rebaseCurrentOnto,this),(0,W.Lb)("gitlens.home.startWork",this.startWork,this),(0,W.Lb)("gitlens.home.createCloudPatch",this.createCloudPatch,this),(0,W.Lb)("gitlens.home.skipPausedOperation",this.skipPausedOperation,this),(0,W.Lb)("gitlens.home.continuePausedOperation",this.continuePausedOperation,this),(0,W.Lb)("gitlens.home.abortPausedOperation",this.abortPausedOperation,this),(0,W.Lb)("gitlens.home.openRebaseEditor",this.openRebaseEditor,this)]}setOverviewFilter(e){this._overviewBranchFilter=e,this.host.notify(eh,{filter:this._overviewBranchFilter})}async onMessageReceived(e){switch(!0){case V.is(e):this.onCollapseSection(e.params);break;case Y.is(e):this.dismissWalkthrough();break;case J.is(e):this.setOverviewFilter(e.params);break;case z.is(e):this.host.respond(z,e,await I(this.container));break;case G.is(e):this.host.respond(G,e,this._overviewBranchFilter);break;case Z.is(e):if(await this.onChooseRepository()==null)return;this.host.notify(Q,void 0);break;case j.is(e):this.onTogglePreviewEnabled();break;case K.is(e):this.openInGraph(e.params);break;case x.is(e):this.host.respond(x,e,await this.getActiveBranchOverview());break;case N.is(e):this.host.respond(N,e,await this.getInactiveBranchOverview())}}includeBootstrap(){return this.getState()}onRefresh(){this.resetBranchOverview(),this.notifyDidChangeRepositories()}onReloaded(){this.onRefresh(),this.notifyDidChangeProgress()}onReady(){!0===this._pendingFocusAccount&&(this._pendingFocusAccount=!1,this.host.notify(el,void 0))}hasRepositoryChanged(){if(this._repositorySubscription?.source!=null){if(this._repositorySubscription.source.etag!==this._etagRepository||this._repositorySubscription.source.etagFileSystem!==this._etagFileSystem)return!0}else if(this._etag!==this.container.git.etag)return!0;return!1}onVisibilityChanged(e){if(!e)return void this._repositorySubscription?.pause();this._repositorySubscription?.resume(),null==this._discovering&&(this.container.subscription.etag!==this._etagSubscription||this.hasRepositoryChanged())&&this.notifyDidChangeRepositories(!0)}openInGraph(e){let t=null!=e?this._repositoryBranches.get(e.repoPath):void 0;if(null==t)return void(0,W.RS)("gitlens.showGraph",this.getSelectedRepository());if("branch"===e.type){let i=t.branches.find(t=>t.id===e.branchId);if(null!=i)return void(0,W.RS)("gitlens.showInCommitGraph",{ref:(0,w.iw)(i)})}(0,W.RS)("gitlens.showGraph",t.repo)}createBranch(){this.container.telemetry.sendEvent("home/createBranch"),(0,W.RS)("gitlens.gitCommands",{command:"branch",state:{subcommand:"create",repo:this.getSelectedRepository(),suggestNameOnly:!0,suggestRepoOnly:!0,confirmOptions:["--switch","--worktree"]}})}async mergeIntoCurrent(e){let{repo:t,branch:i}=await this.getRepoInfoFromRef(e);null!=i&&c.h1(t,(0,w.iw)(i))}async rebaseCurrentOnto(e){let{repo:t,branch:i}=await this.getRepoInfoFromRef(e);null!=i&&c.RU(t,(0,w.iw)(i))}startWork(){this.container.telemetry.sendEvent("home/startWork"),(0,W.RS)("gitlens.startWork",{command:"startWork",source:"home"})}async abortPausedOperation(e){await (0,u._e)(this.container,e.repoPath)}async continuePausedOperation(e){"revert"!==e.type&&await (0,u.Ts)(this.container,e.repoPath)}async skipPausedOperation(e){await (0,u.RG)(this.container,e.repoPath)}async openRebaseEditor(e){if("rebase"!==e.type)return;let t=await this.container.git.config(e.repoPath).getGitDir?.();if(null==t)return;let i=r.Uri.joinPath(t.uri,"rebase-merge","git-rebase-todo");(0,W.S4)("vscode.openWith",i,"gitlens.rebase",{preview:!1})}async createCloudPatch(e){let{repo:t}=await this.getRepoInfoFromRef(e);if(null==t)return;let i=await t.git.status().getStatus();if(null==i)return void r.window.showErrorMessage("Unable to create cloud patch");let s=[];for(let e of i.files){let t={repoPath:e.repoPath,path:e.path,status:e.status,originalPath:e.originalPath,staged:e.staged};s.push(t),e.staged&&e.wip&&s.push({...t,staged:!1})}let o={type:"wip",repository:{name:t.name,path:t.path,uri:t.uri.toString()},files:s,revision:{to:g.SU,from:"HEAD"}};(0,P.X)({mode:"create",create:{changes:[o]}})}onTogglePreviewEnabled(e){void 0===e&&(e=!this.getPreviewEnabled()),this.getPreviewCollapsed()||this.onCollapseSection({section:"newHomePreview",collapsed:!0}),this.container.telemetry.sendEvent("home/preview/toggled",{enabled:e,version:"v16"}),D.H.updateEffective("home.preview.enabled",e)}onCollapseSection(e){let t=this.container.storage.get("home:sections:collapsed");if(null==t){!0===e.collapsed&&this.container.storage.store("home:sections:collapsed",[e.section]).catch();return}let i=t.indexOf(e.section);if(!0===e.collapsed){-1===i&&this.container.storage.store("home:sections:collapsed",[...t,e.section]).catch();return}-1!==i&&(t.splice(i,1),this.container.storage.store("home:sections:collapsed",t).catch())}dismissWalkthrough(){this.container.storage.get("home:walkthrough:dismissed")||(this.container.storage.store("home:walkthrough:dismissed",!0).catch(),this.container.usage.track("home:walkthrough:dismissed").catch())}getWalkthroughDismissed(){return this.container.storage.get("home:walkthrough:dismissed")??!1}getPreviewCollapsed(){return this.container.storage.get("home:sections:collapsed")?.includes("newHomePreview")??!1}getAmaBannerCollapsed(){return Date.now()>=new Date("2025-02-13T13:00:00-05:00").getTime()||(this.container.storage.get("home:sections:collapsed")?.includes("feb2025AmaBanner")??!1)}getIntegrationBannerCollapsed(){return this.container.storage.get("home:sections:collapsed")?.includes("integrationBanner")??!1}getOrgSettings(){return{drafts:(0,$.SD)("gitlens:gk:organization:drafts:enabled",!1),ai:(0,$.SD)("gitlens:gk:organization:ai:enabled",!0)}}onContextChanged(e){"gitlens:gk:organization:drafts:enabled"===e&&this.notifyDidChangeOrgSettings()}async onSubscriptionChanged(e){e.etag!==this._etagSubscription&&(await this.notifyDidChangeSubscription(e.current),(0,S.k0)(e.current.state)!==(0,S.k0)(e.previous.state)&&this.onOverviewRepoChanged())}async getState(e){let[t,i,r]=await Promise.allSettled([this.getSubscriptionState(e),this.getIntegrationStates(!0),this.container.ai.getModel({silent:!0},{source:"home"})]);if("rejected"===t.status)throw t.reason;let s=(0,M.Ro)(i)??[],o=s.some(e=>e.connected),n={model:(0,M.Ro)(r)};return{...this.host.baseWebviewState,discovering:null!=this._discovering,repositories:this.getRepositoriesState(),webroot:this.host.getWebRoot(),subscription:t.value.subscription,avatar:t.value.avatar,organizationsCount:t.value.organizationsCount,orgSettings:this.getOrgSettings(),previewCollapsed:this.getPreviewCollapsed(),integrationBannerCollapsed:this.getIntegrationBannerCollapsed(),integrations:s,ai:n,hasAnyIntegrationConnected:o,walkthroughProgress:this.getWalkthroughDismissed()?void 0:{allCount:this.container.walkthrough.walkthroughSize,doneCount:this.container.walkthrough.doneCount,progress:this.container.walkthrough.progress},previewEnabled:this.getPreviewEnabled(),newInstall:(0,$.SD)("gitlens:install:new",!1),amaBannerCollapsed:this.getAmaBannerCollapsed()}}getPreviewEnabled(){return D.H.get("home.preview.enabled")}getRepositoriesState(){return{count:this.container.git.repositoryCount,openCount:this.container.git.openRepositoryCount,hasUnsafe:this.container.git.hasUnsafeRepositories(),trusted:r.workspace.isTrusted}}async getActiveBranchOverview(){null!=this._discovering&&await this._discovering;let e=this.getSelectedRepository();if(null==e)return;let t="repo"===this._invalidateOverview,i="wip"===this._invalidateOverview,[r,s,o]=await Promise.allSettled([this.getBranchesData(e,t),this.isSubscriptionPro(),this.formatRepository(e)]),{branches:n,worktreesByBranch:a}=(0,M.Ro)(r),h=n.find(e=>"active"===this.getBranchOverviewType(e,a)),l=(0,M.Ro)(s),[u]=em(this.container,[h],a,l,{isActive:!0,forceStatus:!!t||!!i||void 0});return i&&(this._invalidateOverview=void 0),this._etagFileSystem=e.etagFileSystem,{repository:(0,M.Ro)(o),active:u}}async getInactiveBranchOverview(){let e;null!=this._discovering&&await this._discovering;let t=this.getSelectedRepository();if(null==t)return;let i="repo"===this._invalidateOverview,[r,s,o]=await Promise.allSettled([this.getBranchesData(t,i),this.isSubscriptionPro(),this.formatRepository(t)]),{branches:n,worktreesByBranch:a}=(0,M.Ro)(r),h=n.filter(e=>"recent"===this.getBranchOverviewType(e,a)),l=(0,M.Ro)(s);if(this._overviewBranchFilter.stale.show)for(let t of((0,b.Xn)(n,{missingUpstream:!0,orderBy:"date:asc"}),n)){if(null!=e&&e.length>this._overviewBranchFilter.stale.limit)break;h.some(e=>e.id===t.id)||"stale"===this.getBranchOverviewType(t,a)&&(e??=[]).push(t)}let u=em(this.container,h,a,l),c=null==e?void 0:em(this.container,e,a,l);return i||(this._invalidateOverview=void 0),{repository:(0,M.Ro)(o),recent:u,stale:c}}async formatRepository(e){let t=await e.git.remotes().getBestRemotesWithProviders(),i=t.find(e=>e.hasIntegration())??t[0];return{name:e.commonRepositoryName??e.name,path:e.path,provider:i?.provider?{name:i.provider.name,supportedFeatures:i.provider.supportedFeatures,icon:"remote"===i.provider.icon?"cloud":i.provider.icon,url:await i.provider.url({type:p.J.Repo})}:void 0}}_repositorySubscription;selectRepository(e){let t;return null!=e?t=this.container.git.getRepository(e):null==(t=this.container.git.highlander)&&(t=this.container.git.getBestRepositoryOrFirst()),this._repositorySubscription?.dispose(),this._repositorySubscription=void 0,null!=t&&(this._repositorySubscription=new SubscriptionManager(t,e=>this.subscribeToRepository(e)),this.host.visible&&this._repositorySubscription.start()),t}resetBranchOverview(){if(this._repositoryBranches.clear(),!this.host.visible)return void this._repositorySubscription?.pause();this._repositorySubscription?.resume()}subscribeToRepository(e){return r.Disposable.from(e.watchFileSystem(1e3),e.onDidChangeFileSystem(t=>this.onOverviewWipChanged(t,e)),e.onDidChange(t=>{t.changed(d.Z_.Config,d.Z_.Head,d.Z_.Heads,d.Z_.Remotes,d.Z_.PausedOperationStatus,d.Z_.Unknown,d.Ti.Any)&&this.onOverviewRepoChanged(e)}))}onOverviewWipChanged(e,t){e.repository.id===t.id&&this._etagFileSystem!==t.etagFileSystem&&("repo"!==this._invalidateOverview&&(this._invalidateOverview="wip"),this.host.visible&&this.host.notify(et,void 0))}onOverviewRepoChanged(e){if(null!=e){if(this._etagRepository===e.etag)return}else if(this._etag===this.container.git.etag)return;this._invalidateOverview="repo",this.host.visible&&this.notifyDidChangeRepositories()}getSelectedRepository(){return null==this._repositorySubscription&&this.selectRepository(),this._repositorySubscription?.source}_invalidateOverview;_repositoryBranches=new Map;async getBranchesData(e,t=!1){if(t||!this._repositoryBranches.has(e.path)||e.etag!==this._etagRepository){let t=await e.git.worktrees()?.getWorktrees()??[],i=(0,f.PU)(t,{includeDefault:!0}),[r]=await Promise.allSettled([e.git.branches().getBranches({filter:e=>!e.remote,sort:{current:!0,openedWorktreesByBranch:(0,f.vJ)(i)}})]),s=(0,M.Ro)(r)?.values??[];this._etagRepository=e.etag,this._repositoryBranches.set(e.path,{repo:e,branches:s,worktreesByBranch:i})}return this._repositoryBranches.get(e.path)}_integrationStates;_defaultSupportedCloudIntegrations;async getIntegrationStates(e=!1){if(e||null==this._integrationStates){let e=(0,T.x1)(await this.container.integrations.getConfigured(),e=>{if(!(0,a.LT)(e.integrationId))return;let t=a.U4.find(t=>t.id===e.integrationId);return{id:e.integrationId,name:_.Mt[e.integrationId].name,icon:`gl-provider-${_.Mt[e.integrationId].iconKey}`,connected:!0,supports:t?.supports!=null?t.supports:"hosting"===_.Mt[e.integrationId].type?["prs","issues"]:"issues"===_.Mt[e.integrationId].type?["issues"]:[],requiresPro:t?.requiresPro??!1}}),t=await Promise.allSettled(e),i=[...(0,T.x1)(t,e=>(0,M.Ro)(e))];this._defaultSupportedCloudIntegrations??=a.U4.map(e=>({...e,connected:!1})),this._defaultSupportedCloudIntegrations.forEach(e=>{let t=i.find(t=>t.id===e.id);null==t?i.push(e):t.icon!==e.icon&&(t.icon=e.icon)}),i.sort((e,t)=>a.rK.indexOf(e.id)-a.rK.indexOf(t.id)),this._integrationStates=i}return this._integrationStates}_subscription;async getSubscription(e){return null!=e?this._subscription=e:null!=this._subscription?e=this._subscription:this._subscription=e=await this.container.subscription.getSubscription(!0),this._subscription}async isSubscriptionPro(){let e=await this.getSubscription();return null!=e&&(0,S.k0)(e.state)}async getSubscriptionState(e){let t;return e=await this.getSubscription(e),this._etagSubscription=this.container.subscription.etag,t=e.account?.email?(0,o.ML)(e.account.email,34).toString():`${this.host.getWebRoot()??""}/media/gitlens-logo.webp`,{subscription:e,avatar:t,organizationsCount:null!=e?(await this.container.organizations.getOrganizations()??[]).length:0}}notifyDidCompleteDiscoveringRepositories(){this.host.notify(X,{discovering:null!=this._discovering,repositories:this.getRepositoriesState()})}notifyDidChangeRepositoriesCore(){this.host.notify(ei,this.getRepositoriesState())}_notifyDidChangeRepositoriesDebounced=void 0;notifyDidChangeRepositories(e=!1){if(null==this._discovering){if(e)return void this.notifyDidChangeRepositoriesCore();null==this._notifyDidChangeRepositoriesDebounced&&(this._notifyDidChangeRepositoriesDebounced=(0,H.s)(this.notifyDidChangeRepositoriesCore.bind(this),500)),this._notifyDidChangeRepositoriesDebounced()}}notifyDidChangeProgress(){this.host.notify(er,{allCount:this.container.walkthrough.walkthroughSize,doneCount:this.container.walkthrough.doneCount,progress:this.container.walkthrough.progress})}notifyDidChangeConfig(){this.host.notify(ee,{previewEnabled:this.getPreviewEnabled(),previewCollapsed:this.getPreviewCollapsed()})}notifyDidChangeLaunchpad(){this.host.notify(eo,void 0)}async notifyDidChangeIntegrations(){let[e,t]=await Promise.allSettled([this.getIntegrationStates(!0),this.container.ai.getModel({silent:!0},{source:"home"})]),i=(0,M.Ro)(e)??[],r=i.some(e=>e.connected),s={model:(0,M.Ro)(t)};r&&this.onCollapseSection({section:"integrationBanner",collapsed:!0}),this.host.notify(es,{hasAnyIntegrationConnected:r,integrations:i,ai:s})}async notifyDidChangeSubscription(e){let t=await this.getSubscriptionState(e);this.host.notify(en,{subscription:t.subscription,avatar:t.avatar,organizationsCount:t.organizationsCount})}notifyDidChangeOrgSettings(){this.host.notify(ea,{orgSettings:this.getOrgSettings()})}async deleteBranchOrWorktree(e,t){let{repo:i,branch:s}=await this.getRepoInfoFromRef(e);if(null==s)return;let o=!1===s.worktree?void 0:s.worktree??await s.getWorktree();if(s.current&&null!=t&&(!o||o.isDefault)){let i=(0,y.km)(t.branchName),o=await r.window.showWarningMessage(`Before deleting the current branch '${s.name}', you will be switched to '${i}'.`,{modal:!0},{title:"Continue"});if(null==o||"Continue"!==o.title)return;await this.container.git.checkout(e.repoPath,i),(0,h.b)({command:"branch",state:{subcommand:"delete",repo:e.repoPath,references:s}})}else if(null!=i&&null!=o&&!o.isDefault){let e=await i.getCommonRepository(),t=await i.git.worktrees?.()?.getWorktree(e=>e.isDefault);if(null==t||null==e)return;let o=await r.window.showWarningMessage(`Before deleting the worktree for '${s.name}', you will be switched to the default worktree.`,{modal:!0},{title:"Continue"});if(null==o||"Continue"!==o.title)return;let n=D.H.get("deepLinks.schemeOverride"),a="string"==typeof n?n:r.env.uriScheme,l={url:`${a}://${this.container.context.extension.id}/link/${E.vk.Repository}/-/${E.vk.Branch}/${encodeURIComponent(s.name)}?path=${encodeURIComponent(e.path)}&action=delete-branch`,repoPath:e.path,useProgress:!1,state:E.rq.GoToTarget};(0,h.b)({command:"worktree",state:{subcommand:"open",repo:t.repoPath,worktree:t,onWorkspaceChanging:async e=>this.container.storage.store("deepLinks:pending",l),worktreeDefaultOpen:"current"}})}}pushBranch(e){this.container.git.push(e.repoPath,{reference:{name:e.branchName,ref:e.branchId,refType:"branch",remote:!1,repoPath:e.repoPath,upstream:e.branchUpstreamName?{name:e.branchUpstreamName,missing:!1}:void 0}})}mergeTargetCompare(e){return this.container.views.searchAndCompare.compare(e.repoPath,e.branchName,e.mergeTargetName)}async pullRequestCompare(e){let t=await this.getPullRequestFromRef(e);if(t?.refs?.base==null||null==t.refs.head)return void r.window.showErrorMessage("Unable to find pull request to compare");let i=(0,C.tI)(e.repoPath,t.refs);return this.container.views.searchAndCompare.compare(i.repoPath,i.head,i.base)}async pullRequestChanges(e){let t=await this.getPullRequestFromRef(e);if(t?.refs?.base==null||null==t.refs.head)return void r.window.showErrorMessage("Unable to find pull request to open changes");let i=(0,C.tI)(e.repoPath,t.refs);return(0,l.$5)(this.container,{repoPath:i.repoPath,lhs:i.base.ref,rhs:i.head.ref},{title:`Changes in Pull Request #${t.id}`})}async pullRequestViewOnRemote(e,t){let i=await this.getPullRequestFromRef(e);if(null==i)return void r.window.showErrorMessage("Unable to find pull request to open on remote");(0,W.RS)("gitlens.openPullRequestOnRemote",{pr:{url:i.url},clipboard:t})}async pullRequestDetails(e){let t=await this.getPullRequestFromRef(e);if(null==t)return void r.window.showErrorMessage("Unable to find pull request to open details");this.container.views.pullRequest.showPullRequest(t,e.repoPath)}async pullRequestCreate({ref:e,describeWithAI:t,source:i}){let{branch:r}=await this.getRepoInfoFromRef(e);if(null==r)return;let o=await r.getRemote(),n=t?this.container.actionRunners.get("createPullRequest")?.find(e=>e.type===s.do.BuiltIn)?.id:void 0;(0,W.ph)("createPullRequest",{repoPath:e.repoPath,remote:null!=o?{name:o.name,provider:null!=o.provider?{id:o.provider.id,name:o.provider.name,domain:o.provider.domain}:void 0,url:o.url}:void 0,branch:{name:r.name,upstream:r.upstream?.name,isRemote:r.remote},describeWithAI:t,source:i},n)}async worktreeOpen(e){let{branch:t}=await this.getRepoInfoFromRef(e),i=await t?.getWorktree();null!=i&&(0,q.OH)(i.uri)}async switchToBranch(e){let{repo:t,branch:i}=await this.getRepoInfoFromRef(e);null!=i&&c.S_(t,(0,w.iw)(i))}async fetch(e){if(null==e){let e=this.getSelectedRepository();c.hd(e);return}let{repo:t,branch:i}=await this.getRepoInfoFromRef(e);null!=i&&c.hd(t,(0,w.iw)(i))}getBranchOverviewType(e,t){if(e.current||t.get(e.id)?.opened)return"active";let i=e.date?.getTime();if(null!=i){let e=Date.now();if(i>e-eg[this._overviewBranchFilter.recent.threshold])return"recent";if(i<e-eg[this._overviewBranchFilter.stale.threshold])return"stale"}if(e.upstream?.missing)return"stale"}async getPullRequestFromRef(e){let{branch:t}=await this.getRepoInfoFromRef(e);return t?.getAssociatedPullRequest()}async getRepoInfoFromRef(e){let t=this.container.git.getRepository(e.repoPath);if(null==t)return{repo:void 0,branch:void 0};let i=await t.git.branches().getBranch(e.branchName);return{repo:t,branch:i}}};function em(e,t,i,r,s){let o,n;if(0===t.length)return[];let a=s?.isActive??!1,h=s?.forceStatus?{force:!0}:void 0,l=new Map,u=new Map,c=new Map,d=new Map,g=new Map,v=new Map,b=new Map,f=[];for(let s of t){s.upstream?.missing===!1&&l.set(s.id,s.getRemote());let t=i.get(s.id),p=s.date?.getTime();!0===r&&(u.set(s.id,ey(e,s,o)),c.set(s.id,s.getEnrichedAutolinks()),d.set(s.id,(0,m.GI)(e,s).then(e=>e.value)),v.set(s.id,e.git.branches(s.repoPath).getBranchContributionsOverview(s.ref)),s.current&&b.set(s.id,eb(e,s))),null!=t?g.set(s.id,t.getStatus(h)):!0===a&&(void 0===n&&(n=e.git.status(s.repoPath).getStatus()),g.set(s.id,n)),f.push({reference:(0,w.iw)(s),repoPath:s.repoPath,id:s.id,name:s.name,opened:a,timestamp:p,status:s.status,upstream:s.upstream,worktree:t?{name:t.name,uri:t.uri.toString(),isDefault:t.isDefault}:void 0})}return f.length>0&&function(e,t,i,r,s,o,n,a,h,l){for(let u of t){u.remote=r.get(u.id)?.then(async e=>{if(null!=e)return{name:e.name,provider:e.provider?{name:e.provider.name,icon:"remote"===e.provider.icon?"cloud":e.provider.icon,url:await e.provider.url({type:p.J.Repo}),supportedFeatures:e.provider.supportedFeatures}:void 0}}),u.pr=s.get(u.id);let t=o.get(u.id);u.autolinks=t?.then(e=>ev(e));let c=n.get(u.id);u.issues=c?.then(e=>e?.map(e=>({id:e.id,title:e.title,state:e.state,url:e.url}))??[]),u.wip=eC(e,u,a.get(u.id),i);let d=h.get(u.id);u.contributors=ew(e,d),u.mergeTarget=l.get(u.id)}}(e,f,a,l,u,c,d,g,v,b),f}async function ev(e){return null==e?[]:(await Promise.allSettled((0,T.x1)([...e.values()],async e=>{let t=e?.[0];if(null==t)return;let i=await t;if(null!=i)return{id:i.id,title:i.title,url:i.url,state:i.state}}))).map(e=>"fulfilled"===e.status?e.value:void 0).filter(e=>null!=e)}async function ew(e,t){if(null==t)return[];let i=await t;return i?.contributors==null?[]:(await Promise.allSettled(i.contributors.map(async e=>({name:e.name??"",email:e.email??"",current:e.current,timestamp:e.latestCommitDate?.getTime(),count:e.commits,stats:e.stats,avatarUrl:(await e.getAvatarUri())?.toString()})))).map(e=>"fulfilled"===e.status?e.value:void 0).filter(e=>null!=e)}async function eb(e,t){let i,r=await (0,v.y1)(e,t,{associatedPullRequest:t.getAssociatedPullRequest()});!r.targetBranch.paused&&r.targetBranch.value&&(i=r.targetBranch.value);let s=i??r.baseBranch??r.defaultBranch;if(null==s)return;let o=e.git.branches(t.repoPath),n=await o.getBranch(s);if(null==n)return;let[a,h,l]=await Promise.allSettled([e.git.commits(t.repoPath).getLeftRightCommitCount((0,R.Xn)(n.name,t.ref,"..."),{excludeMerges:!0}),o.getPotentialMergeOrRebaseConflict?.(t.name,n.name),o.getBranchMergedStatus?.(t,n)]),u=(0,M.Ro)(a),c=null!=u?{ahead:u.right,behind:u.left}:void 0,p=(0,M.Ro)(l);return{repoPath:t.repoPath,id:n.id,name:n.name,status:c,mergedStatus:p,potentialConflicts:(0,M.Ro)(h),targetBranch:n.name,baseBranch:r.baseBranch,defaultBranch:r.defaultBranch}}async function ef(e,t,i){i??=e.launchpad.getCategorizedItems();let r=await i;if(null!=r.error)return;let s=r.items.find(e=>e.url===t.url);if(null==s){if(null!=(r=await e.launchpad.getCategorizedItems({search:[t]})).error)return;s=r.items.find(e=>e.url===t.url)}if(null!=s)return{uuid:s.uuid,category:s.actionableCategory,groups:(0,k._v)(s),suggestedActions:s.suggestedActions,failingCI:s.failingCI,hasConflicts:s.hasConflicts,review:{decision:s.reviewDecision,reviews:s.reviews??[],counts:{approval:s.approvalReviewCount,changeRequest:s.changeRequestReviewCount,comment:s.commentReviewCount,codeSuggest:s.codeSuggestionsCount}},author:s.author,createdDate:s.createdDate,viewer:{...s.viewer,enrichedItems:void 0}}}async function ey(e,t,i){let r=await t.getAssociatedPullRequest({avatarSize:64});if(null!=r)return{id:r.id,url:r.url,state:r.state,title:r.title,draft:r.isDraft,launchpad:ef(e,r,i)}}async function eC(e,t,i,r){if(null==i)return;let[s,o]=await Promise.allSettled([i,r?e.git.status(t.repoPath).getPausedOperationStatus?.():void 0]),n=(0,M.Ro)(s),a=(0,M.Ro)(o);return{workingTreeState:n?.getDiffStatus(),hasConflicts:n?.hasConflicts,conflictsCount:n?.conflicts.length,pausedOpStatus:a}}ep([(0,L.Rm)({args:{0:e=>`${e?.type}, repoPath=${e?.repoPath}, branchId=${e?.branchId}`}})],HomeWebviewProvider.prototype,"openInGraph",1),ep([(0,L.Rm)()],HomeWebviewProvider.prototype,"createBranch",1),ep([(0,L.Rm)({args:{0:e=>e.branchId}})],HomeWebviewProvider.prototype,"mergeIntoCurrent",1),ep([(0,L.Rm)({args:{0:e=>e.branchId}})],HomeWebviewProvider.prototype,"rebaseCurrentOnto",1),ep([(0,L.Rm)()],HomeWebviewProvider.prototype,"startWork",1),ep([(0,L.Rm)({args:{0:e=>e.type}})],HomeWebviewProvider.prototype,"abortPausedOperation",1),ep([(0,L.Rm)({args:{0:e=>e.type}})],HomeWebviewProvider.prototype,"continuePausedOperation",1),ep([(0,L.Rm)({args:{0:e=>e.type}})],HomeWebviewProvider.prototype,"skipPausedOperation",1),ep([(0,L.Rm)({args:{0:e=>e.type}})],HomeWebviewProvider.prototype,"openRebaseEditor",1),ep([(0,L.Rm)({args:{0:e=>e.branchId}})],HomeWebviewProvider.prototype,"createCloudPatch",1),ep([(0,L.Rm)()],HomeWebviewProvider.prototype,"dismissWalkthrough",1),ep([(0,L.Yz)({args:!1})],HomeWebviewProvider.prototype,"onSubscriptionChanged",1),ep([(0,L.Yz)({args:{0:!1}})],HomeWebviewProvider.prototype,"onOverviewWipChanged",1),ep([(0,L.Yz)()],HomeWebviewProvider.prototype,"onOverviewRepoChanged",1),ep([(0,L.Rm)({args:{0:e=>`${e.branchId}, upstream: ${e.branchUpstreamName}`,1:e=>e?.branchId}})],HomeWebviewProvider.prototype,"deleteBranchOrWorktree",1),ep([(0,L.Rm)({args:{0:e=>`${e.branchId}, upstream: ${e.branchUpstreamName}`}})],HomeWebviewProvider.prototype,"pushBranch",1),ep([(0,L.Rm)({args:{0:e=>`${e.branchId}, upstream: ${e.branchUpstreamName}, mergeTargetId: ${e.mergeTargetId}`}})],HomeWebviewProvider.prototype,"mergeTargetCompare",1),ep([(0,L.Rm)({args:{0:e=>`${e.branchId}, upstream: ${e.branchUpstreamName}`}})],HomeWebviewProvider.prototype,"pullRequestCompare",1),ep([(0,L.Rm)({args:{0:e=>`${e.branchId}, upstream: ${e.branchUpstreamName}`}})],HomeWebviewProvider.prototype,"pullRequestChanges",1),ep([(0,L.Rm)({args:{0:e=>`${e.branchId}, upstream: ${e.branchUpstreamName}`}})],HomeWebviewProvider.prototype,"pullRequestViewOnRemote",1),ep([(0,L.Rm)({args:{0:e=>`${e.branchId}, upstream: ${e.branchUpstreamName}`}})],HomeWebviewProvider.prototype,"pullRequestDetails",1),ep([(0,L.Rm)({args:{0:e=>`${e.ref.branchId}, upstream: ${e.ref.branchUpstreamName}`}})],HomeWebviewProvider.prototype,"pullRequestCreate",1),ep([(0,L.Rm)({args:{0:e=>`${e.branchId}, worktree: ${e.worktree?.name}`}})],HomeWebviewProvider.prototype,"worktreeOpen",1),ep([(0,L.Rm)({args:{0:e=>e.branchId}})],HomeWebviewProvider.prototype,"switchToBranch",1),ep([(0,L.Rm)({args:{0:e=>e?.branchId}})],HomeWebviewProvider.prototype,"fetch",1)}};